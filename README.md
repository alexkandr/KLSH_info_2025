Примеры кода в main.ipynb. Текст:   

# Вступление
>__Талантливый школьник во время сезона 2024 нарисовал новый логотип Красноярской Летней Школы. Оно так всем понравилось, что дирекция решила отсканировать это изображение и сохранить его на компьюетере. Получился файл формата BMP с расширением ".bmp"__

Эту картинку можно найти по ссылке (?):   

<img src="logo.bmp" width="200" height="200">

Известно, что байтовое представление .bmp изображения имеет следующую структуру :
1. BITMAPFILEHEADER - первые 14 байт
1. BITMAPINFO - в наших задачах это всегда будут следующие 40 байт
1. Пиксельные данные - всё остальное

Подробную информацию про формат можно прочитать на [википедии](https://ru.wikipedia.org/wiki/BMP#Таблица_цветов), но из всех этих данных нас будут интересовать в основном следующее:
1. с 0A по 0С (10-14) байт запсиано положение пиксельных данных относительно начала файла
1. с 12 по 16 (18-22) байт записана ширина изображения в пикселях
1. с 16 по 2A (22-26) байт записана высота изображения в пикселях. Если это число положительное, то строки пикселеей записаны снизу вверх. Если это число отрицательное, то запись строк идёт сверху вниз, причём количество строк равно абсолютному значению этого числа
1. с 1С по 1E (28-30) байт записано количество бит, которым шифруется каждый пиксель. В нашем случае - 24 бита = 3 байта

Пиксельные данные записаны последовательностью цветов пикселей по следующим правилам:
- Всё изображение разбито на однопиксельные строки, которые идут по порядку
- Каждый пиксель зашифрован тремя числами от 0 до 255 в палитре rgb - то есть значениями, ***синей, зелёной и красной*** компонент цвета пикселя, __именно в таком порядке__. 
- Пиксели в каждой строке записаны строго слева направо. 
- Количество байт в каждой строке должно делиться на 4. Если количество байт не делится на 4, то в конец каждой строки дописывается необходимое количество нулей.  
- Порядок строк зависит от значения высоты, записанной в BITMAPINFO. Отрицательный - сверху вниз, положительный - снизу вверх.

## Пример
Чтобы лучше разобраться, как это работает, давайте рассмотрим следующий пример изображения из 4 пикселей, (увеличено для наглядности, могут быть артефакты).    
Изображение можно найти по ссылке(?)

<img src="example.bmp" width="50" height="50">

Всё это изображение занимает ровно 70 байт.
1. Первые 14 байт секции BITMAPFILEHEADER:      
```42 4d``` ```46 00 00 00``` ```00 00``` ``` 00 00``` ``` 36 00 00 00```       
Последние 4 байта хранят позицию, с которого начнутся пиксельные данные.    
Чтобы правильно считать число состоящее из 4 байт, нам необходимо читать байты в "порядке от младшего к старшему" ("little-endian" или просто "little")     
В нашем случае пиксельные данные начнутся с 54 (3*16 + 6 = 54) байта.    
1. Следующие 40 байт секции BITMAPINFO:     
```28 00 00 00``` ``` 02 00 00 00``` ``` 02 00 00 00``` ``` 01 00``` ``` 18 00``` ``` 00 00 00 00``` ``` 10 00 00 00``` ``` c4 0e 00 00``` ``` c4 0e 00 00``` ``` 00 00 00 00``` ``` 00 00 00 00```       
В этих данных мы можем найти много полезной информации, например:
    - Ширина изображения равна ```02``` пикселей 
    - Высота изображения равна ```02``` пикселей. 2 - положительное число, а значит строки будут записаны в обратном порядке
    - Каждый пиксель кодируется 24 (1*16 + 8 = 24) битами, или 3 байтами
1. Оставшиеся 16 байт пиксельных данных запишем строками:    
```ff 00 00``` ```ff ff ff``` ```00 00```   
```00 00 ff``` ```00 ff 00``` ```00 00```
    1. Как мы уже знаем, строки записаны снизу вверх, причём каждый пиксель записан 3 байтами в порядке (Синий, Зелёный, Красный)    
    1. Сначала идёт левый нижний писель ```ff 00 00``` - синий
    1. Потом правый нижний пиксель - ```ff ff ff``` - белый
    1. Потом идут 2 байта ```00 00```, которые нужны, чтобы количество байт в строке делилось на 4. (2 * 3 + 2 = 8)
    1. Потом Левый верхний пиксель - ```00 00 ff``` - красный
    1. Потом Правый верхний пиксель - ```00 ff 00``` - зелёный
    1. И в самом конце стоят 2 байта ```00 00```, которые нужны, чтобы количество байт делилось на 4.


# Задание 1 (3 балла):   
>__Из-за ошибки при сканировании, изображение получилось перевёрнутым.__         
__Тебя попросили вернуть изображению правильную ориентацию__
## Задание:
Напишите функцию (метод) ```vertical_reverse_image(input_image, result_image)```
, которая изменит порядок строк изображения на противоположный.    
У этой функции должно быть два аргумета:     
- ```input_image : string``` - относительный или абсолютный путь к BMP изображению описанного выше формата.
- ```result_image : string``` - относительный или абсолютный путь, по которому будет записан результат выполнения функции.   
    
Эта функция (метод) должен использовать только функции стандартных библиотек вашего языка программирования.

# Задание 2 (5 баллов)
>__Дирекция очень довольна твоей работой и захотела отправить это изображение по интернету из Орбиты в Красноярск, но интернет в Орибте очень медленный, а наше изображение весит целых 7,5 Мегабайт!__     
__Тебя попросили сжать это изображение так, чтобы при разжатии можно было восстановить, в точности то же самое изображение.__

Давайте посмотрим на верхнюю пиксельную строку нашего изображения. Она же состоит из белого пикселя "ff ff ff" повторенного много раз (столько раз, сколько влезает в одну строку изображения).     
Но!     
Мы же можем сильно сокртатить запись этого изображения, если вместо текущей записи укажем что-то вроде      
**"пиксель ff ff ff стоит 1629 раз"**, или просто **"1629 ff ff ff "**.      
Вспомним теперь, что числа у нас тоже хранятся в байтах, поэтому под число повторов мы выделим один байт. Тогда запись будет выглядеть следующим образом: **"256 ff ff ff , 256 ff ff ff , ...,  93 ff ff ff "**.      
Но даже такая запись сильно сократит размер нашего файла, ведь теперь первая строка будет занимать **28 вместо 4887 байт!**  
## Задание:
1. Напишите две функции ```compress(input_image, result_image)``` и ```decompress(input_image, result_image)```, которые будут сжимать и разжимать обратно файл изображения по заданному алгоритму.
    - ```input_image : string``` - относительный или абсолютный путь к BMP изображению описанного выше формата.
    - ```result_image : string``` - относительный или абсолютный путь, по которому будет записан результат выполнения функции.   

    Результатом сжатия (функции ```compress()```) должен стать файл формата ".cmp", который получается из оригинального BMP файла по следующему алгоритму:
    1. Первые 54 байта файла .cmp такие же как и файла .bmp
    1. Далее идёт пиксельная информация: каждый пиксель теперь кодируется следующим образом: сначала один байт - количество раз, которое некоторый цвет встречается подряд, а потом 3 байта, которые кодируют цвет пикселя в палитре rgb

    Результатом разжатия (функции ```decompress()```) должно стать BMP изображение, разжатое из файла ".cmp"         
    Эти функции должны использовать только функции стандартных библиотек вашего языка программирования.
1. Приведи пример изображения, которое алгоритм сжимает в наибольшее количество раз. 

>Всегда ли алгоритм стоит применять?
----

# Задание 3 (7 баллов)
1. Какие недостатки ты нашёл(ла) в реализованном алгоритме сжатия?

Некоторые проблемы можно устранить, если при сжатии потерять часть информации, имеющуюся в изображении. Например, если нескольким пикселям, которые имели раньше разные цвета при сжатии присваивать одинаковый.

2. Напишите функцию ```super_compress(input_image, result_image)``` , которая улучшит степень сжатия файла алгоритмом из задания 2, засчёт потери части информации, и функцию ```super_decompress(input_image, result_image)```, которая отрисует изображение BMP по сохранившейся информации. Постарайтесь сделать так, чтобы изначальное и изображение в результате последовательного сжатия и разжатия не сильно отличались друг от друга.